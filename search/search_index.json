{
    "docs": [
        {
            "location": "/", 
            "text": "Yet Another Traffic Engineering System\n\n\nOverview\n\n\nYATES\n \n is a software framework that enables\nrapid prototyping and evaluation of traffic engineering systems.  Yates comes\nwith two backends: a network simulator that calculates congestion, throughput,\nloss, latency, etc., and an SDN-based implementation that can be used to\nvalidate results obtained via simulation and also provides an easy path to\ndeployment.\n\n\n\n\n\n\n\n\nTopology\n\n\n\n\nTraffic Matrices\n\n\n\n\n\n\n\n\n\n\n\n\n+\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYATES\n\n\n\n\n\n\n\n\n\nPerformance metrics\n\n\n\n\n\n\n\nPapers\n\n\n\n\nPraveen Kumar, Chris Yu, Yang Yuan, Nate Foster, Robert Kleinberg, and Robert Soul\u00e9. \nYATES: Rapid Prototyping for Traffic Engineering Systems\n. In \nACM SIGCOMM Symposium on Software-Defined Networking Research (SOSR), Los Angeles, CA\n, March 2018.", 
            "title": "Home"
        }, 
        {
            "location": "/#yet-another-traffic-engineering-system", 
            "text": "", 
            "title": "Yet Another Traffic Engineering System"
        }, 
        {
            "location": "/#overview", 
            "text": "YATES    is a software framework that enables\nrapid prototyping and evaluation of traffic engineering systems.  Yates comes\nwith two backends: a network simulator that calculates congestion, throughput,\nloss, latency, etc., and an SDN-based implementation that can be used to\nvalidate results obtained via simulation and also provides an easy path to\ndeployment.     Topology   Traffic Matrices       +         YATES     Performance metrics", 
            "title": "Overview"
        }, 
        {
            "location": "/#papers", 
            "text": "Praveen Kumar, Chris Yu, Yang Yuan, Nate Foster, Robert Kleinberg, and Robert Soul\u00e9.  YATES: Rapid Prototyping for Traffic Engineering Systems . In  ACM SIGCOMM Symposium on Software-Defined Networking Research (SOSR), Los Angeles, CA , March 2018.", 
            "title": "Papers"
        }, 
        {
            "location": "/installation/", 
            "text": "Installation\n\n\nThis page describes the process to build and install YATES from source. It also\nlists the commands that you would need to execute on a system running Ubuntu\n(\n= 16.04).\n\n\nQuickstart\n\n\nHere's a list of commands to get you quickly started with a YATES installation.\nFor more details, read the following sections.\n\n\nexport\n \nOPAMYES\n=\n1\n\n\nexport\n \nOPAMVERBOSE\n=\n1\n\nsudo add-apt-repository ppa:avsm/ppa -y\nsudo apt-get update -qq\nsudo apt-get install -qq git ocaml ocaml-native-compilers camlp4-extra opam\nopam update\nopam switch \n4\n.06.0\n\neval\n \n`\nopam config env\n`\n\nopam install jbuilder\ngit clone https://github.com/cornell-netlab/yates.git\n\ncd\n yates\nopam pin add --yes --no-action yates .\nopam install --yes --deps-only yates\nmake \n make install\n\n\n\n\n\nIf there's an error with the above set of commands, please read the\nfollowing step-by-step guide.\n\n\n\n\nRequirements\n\n\nYATES requires the following to be installed on the system.\n\n\n\n\nOCaml (\n= 4.06.0)\n and the OCaml package manager \nOpam\n. Install these using:\n\n\n\n\nsudo add-apt-repository ppa:avsm/ppa\nsudo apt-get update\nsudo apt-get install ocaml ocaml-native-compilers camlp4-extra opam\n\n\n\n\n\nand switch to the 4.06.0 compiler as:\n\n\nopam init --auto-setup --compiler\n=\n4\n.06.0\n\neval\n \n`\nopam config env\n`\n\n\n\n\n\n\nIf you had a version of OCaml already installed, then make sure you are using the correct compiler version for YATES.\n\n\nocaml --version\n\n\n\n\n\nIf not, update the compiler version:\n\n\nopam update\nopam switch \n4\n.06.0\n\neval\n \n`\nopam config env\n`\n\n\n\n\n\n\n\n\nYATES uses the \nDune (jbuilder)\n build system. Install it using Opam:\n\n\n\n\nopam install jbuilder\n\n\n\n\n\n\n\n[Optional but recommended] YATES uses the \nGurobi Optimizer\n to solve linear\n    programs (LP). So, if you are planning to use a TE system that needs to\n    solve an LP, \ninstall Gurobi\n.\n    Gurobi offers a \nfree academic license\n.\n    Follow the \nSoftware Installation Guide\n for instructions on installing Gurobi and setting up a license.\n    Finally, make sure that \ngurobi_cl\n is in \n$PATH\n and you have a valid license.\n\n\n\n\ngurobi_cl --license\n\n\n\n\n\n\n\nDownload\n\n\nGet the latest source code for YATES from GitHub:\n\n\ngit clone https://github.com/cornell-netlab/yates.git\n\n\n\n\n\n\n\nSetup and build\n\n\n\n\nGo to newly created \nyates\n directory and run the following command to generate\nthe list of dependencies for YATES:\n\n\n\n\ncd\n yates\njbuilder external-lib-deps --missing @install\n\n\n\n\n\nInstall the dependencies these using \nopam\n. For instance, to install Frenetic,\nrun:\n\n\nopam install frenetic\n\n\n\n\n\n\n\nYou can also install the dependencies in a more automated way using \nopam\n as:\n\n\n\n\ncd\n yates\nopam pin add --yes --no-action yates .\nopam install --yes --deps-only yates\n\n\n\n\n\n\n\nOnce the dependencies have been installed, build and install YATES as:\n\n\n\n\nmake \n make install\n\n\n\n\n\nThis will generate and install two binaries:\n\n\n\n\nyates\n: the YATES simulator and\n\n\nyates.ctrl\n: the YATES SDN controller.\n\n\n\n\n\n\nVerify\n\n\nFinally, verify that the installation of YATES succeeded by running:\n\n\nyates -h\n\n\n\n\n\nand\n\n\nyates.ctrl -h", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "This page describes the process to build and install YATES from source. It also\nlists the commands that you would need to execute on a system running Ubuntu\n( = 16.04).", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#quickstart", 
            "text": "Here's a list of commands to get you quickly started with a YATES installation.\nFor more details, read the following sections.  export   OPAMYES = 1  export   OPAMVERBOSE = 1 \nsudo add-apt-repository ppa:avsm/ppa -y\nsudo apt-get update -qq\nsudo apt-get install -qq git ocaml ocaml-native-compilers camlp4-extra opam\nopam update\nopam switch  4 .06.0 eval   ` opam config env ` \nopam install jbuilder\ngit clone https://github.com/cornell-netlab/yates.git cd  yates\nopam pin add --yes --no-action yates .\nopam install --yes --deps-only yates\nmake   make install  If there's an error with the above set of commands, please read the\nfollowing step-by-step guide.", 
            "title": "Quickstart"
        }, 
        {
            "location": "/installation/#requirements", 
            "text": "YATES requires the following to be installed on the system.   OCaml ( = 4.06.0)  and the OCaml package manager  Opam . Install these using:   sudo add-apt-repository ppa:avsm/ppa\nsudo apt-get update\nsudo apt-get install ocaml ocaml-native-compilers camlp4-extra opam  and switch to the 4.06.0 compiler as:  opam init --auto-setup --compiler = 4 .06.0 eval   ` opam config env `   If you had a version of OCaml already installed, then make sure you are using the correct compiler version for YATES.  ocaml --version  If not, update the compiler version:  opam update\nopam switch  4 .06.0 eval   ` opam config env `    YATES uses the  Dune (jbuilder)  build system. Install it using Opam:   opam install jbuilder   [Optional but recommended] YATES uses the  Gurobi Optimizer  to solve linear\n    programs (LP). So, if you are planning to use a TE system that needs to\n    solve an LP,  install Gurobi .\n    Gurobi offers a  free academic license .\n    Follow the  Software Installation Guide  for instructions on installing Gurobi and setting up a license.\n    Finally, make sure that  gurobi_cl  is in  $PATH  and you have a valid license.   gurobi_cl --license", 
            "title": "Requirements"
        }, 
        {
            "location": "/installation/#download", 
            "text": "Get the latest source code for YATES from GitHub:  git clone https://github.com/cornell-netlab/yates.git", 
            "title": "Download"
        }, 
        {
            "location": "/installation/#setup-and-build", 
            "text": "Go to newly created  yates  directory and run the following command to generate\nthe list of dependencies for YATES:   cd  yates\njbuilder external-lib-deps --missing @install  Install the dependencies these using  opam . For instance, to install Frenetic,\nrun:  opam install frenetic   You can also install the dependencies in a more automated way using  opam  as:   cd  yates\nopam pin add --yes --no-action yates .\nopam install --yes --deps-only yates   Once the dependencies have been installed, build and install YATES as:   make   make install  This will generate and install two binaries:   yates : the YATES simulator and  yates.ctrl : the YATES SDN controller.", 
            "title": "Setup and build"
        }, 
        {
            "location": "/installation/#verify", 
            "text": "Finally, verify that the installation of YATES succeeded by running:  yates -h  and  yates.ctrl -h", 
            "title": "Verify"
        }, 
        {
            "location": "/tutorial/", 
            "text": "Basic Tutorial\n\n\nGetting Started\n\n\nThis section will show the basic usage of YATES using some TE algorithms,\ntopologies and example demand traffic matrices already included with YATES.\n\n\n\n\nInputs\n\n\nAt the minimum, YATES needs the following inputs:\n\n\n\n\nTopology: A topology is represented as a graph in the \nDOT file format\n. We\n    will use Abilene's backbone network topology in\n    \ndata/topologies/abilene.dot\n.\n\n\nDemands: These are represented as a list of traffic matrices (TMs). Each TM\n    represents the bandwidth requirement from a source to a destination at a\n    given time. YATES expects TMs as a single file (example:\n    \ndata/demands/actual/abilene.txt\n), with each line\n    corresponding to one TM. Each line represents the rows of the TM\n    concatenated together. To identify which entry in the TM corresponds to\n    a particular source and destination node pair, we also need to provide a mapping from\n    rows/columns in the TM to the corresponding end-points in the topology\n    (example: \ndata/hosts/abilene.hosts\n.\n    The line number of each node in this file is its index in the rows/columns of a TM).\n\n\n\n\n\n\nBasic Usage\n\n\nThe following command shows how to run the YATES simulator for the above\nmentioned inputs and evaluates the performance of Equal-Cost Multi-Path (ECMP)\nbased TE:\n\n\n# \nsimulator\n \nactual-demands\n \npredicted-demands\n \nhost-mapping\n \\\n\n\n#  [optional parameters for evaluation such as TE algorithms, budget etc.]\n\nyates data/topologies/abilene.dot \n\\\n\n  data/demands/actual/abilene.txt data/demands/predicted/abilene.txt \n\\\n\n  data/hosts/abilene.hosts -ecmp\n\n\n\n\n\n\n\nThe simulator will iterate over all the TMs in the specified file and generate\na summary of the performance statistics in \ndata/results/abilene\n. For\ninstance, \ndata/results/abilene/MaxCongestionVsIterations.dat\n will list the\nmaximum link congestion for each TM when using ECMP.\n\n\n\n\nComparing TE systems\n\n\nTo compare multiple TE algorithms in the same run, they can be specified\ntogether as command line flags. For example, to compare ECMP, k-shortest paths\n(KSP) and multi-commodity flow based TE (MCF) using the same topologies and\ndemands, we can run the following:\n\n\n# \nsimulator\n \nactual-demands\n \npredicted-demands\n \nhost-mapping\n \\\n\n\n#  [optional parameters for evaluation such as TE algorithms, budget etc.]\n\nyates data/topologies/abilene.dot \n\\\n\n  data/demands/actual/abilene.txt data/demands/predicted/abilene.txt \n\\\n\n  data/hosts/abilene.hosts -ecmp -ksp -mcf\n\n\n\n\n\nYATES will iterate over the sequence of TE algorithms and generate performance\nstatistics with each TE algorithm in the same output directory as earlier.\n\n\n\n\n\n\nOperational Constraints\n\n\nYATES allows users to specify various operational constraints while evaluating\nthe performance of TE algorithms. For example, one can constrain TE algorithms\nto use up to a specified maximum number of paths between every\nsource-destination pair. The following command sets this path budget to 4:\n\n\nyates \n[\n... parameters ...\n]\n -budget \n4\n\n\n\n\n\n\n\n\nMore Options\n\n\nYATES supports a lot of other options to specify different TE systems and\ngenerate different kinds of workloads and operational scenarios. See the help\nin CLI for the exhaustive list.\n\n\nyates -h", 
            "title": "Basic Tutorial"
        }, 
        {
            "location": "/tutorial/#basic-tutorial", 
            "text": "", 
            "title": "Basic Tutorial"
        }, 
        {
            "location": "/tutorial/#getting-started", 
            "text": "This section will show the basic usage of YATES using some TE algorithms,\ntopologies and example demand traffic matrices already included with YATES.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/tutorial/#inputs", 
            "text": "At the minimum, YATES needs the following inputs:   Topology: A topology is represented as a graph in the  DOT file format . We\n    will use Abilene's backbone network topology in\n     data/topologies/abilene.dot .  Demands: These are represented as a list of traffic matrices (TMs). Each TM\n    represents the bandwidth requirement from a source to a destination at a\n    given time. YATES expects TMs as a single file (example:\n     data/demands/actual/abilene.txt ), with each line\n    corresponding to one TM. Each line represents the rows of the TM\n    concatenated together. To identify which entry in the TM corresponds to\n    a particular source and destination node pair, we also need to provide a mapping from\n    rows/columns in the TM to the corresponding end-points in the topology\n    (example:  data/hosts/abilene.hosts .\n    The line number of each node in this file is its index in the rows/columns of a TM).", 
            "title": "Inputs"
        }, 
        {
            "location": "/tutorial/#basic-usage", 
            "text": "The following command shows how to run the YATES simulator for the above\nmentioned inputs and evaluates the performance of Equal-Cost Multi-Path (ECMP)\nbased TE:  #  simulator   actual-demands   predicted-demands   host-mapping  \\  #  [optional parameters for evaluation such as TE algorithms, budget etc.] \nyates data/topologies/abilene.dot  \\ \n  data/demands/actual/abilene.txt data/demands/predicted/abilene.txt  \\ \n  data/hosts/abilene.hosts -ecmp   The simulator will iterate over all the TMs in the specified file and generate\na summary of the performance statistics in  data/results/abilene . For\ninstance,  data/results/abilene/MaxCongestionVsIterations.dat  will list the\nmaximum link congestion for each TM when using ECMP.", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/tutorial/#comparing-te-systems", 
            "text": "To compare multiple TE algorithms in the same run, they can be specified\ntogether as command line flags. For example, to compare ECMP, k-shortest paths\n(KSP) and multi-commodity flow based TE (MCF) using the same topologies and\ndemands, we can run the following:  #  simulator   actual-demands   predicted-demands   host-mapping  \\  #  [optional parameters for evaluation such as TE algorithms, budget etc.] \nyates data/topologies/abilene.dot  \\ \n  data/demands/actual/abilene.txt data/demands/predicted/abilene.txt  \\ \n  data/hosts/abilene.hosts -ecmp -ksp -mcf  YATES will iterate over the sequence of TE algorithms and generate performance\nstatistics with each TE algorithm in the same output directory as earlier.", 
            "title": "Comparing TE systems"
        }, 
        {
            "location": "/tutorial/#operational-constraints", 
            "text": "YATES allows users to specify various operational constraints while evaluating\nthe performance of TE algorithms. For example, one can constrain TE algorithms\nto use up to a specified maximum number of paths between every\nsource-destination pair. The following command sets this path budget to 4:  yates  [ ... parameters ... ]  -budget  4", 
            "title": "Operational Constraints"
        }, 
        {
            "location": "/tutorial/#more-options", 
            "text": "YATES supports a lot of other options to specify different TE systems and\ngenerate different kinds of workloads and operational scenarios. See the help\nin CLI for the exhaustive list.  yates -h", 
            "title": "More Options"
        }, 
        {
            "location": "/extending/", 
            "text": "Extending YATES\n\n\nOne of the primary objectives of YATES is to enable rapid prototyping of TE\nsystems. This page will demonstrate how to implement a new TE algorithm with\nYATES.\n\n\n\n\nExample: Valiant Load Balancing (VLB)\n\n\nVLB\n: Suppose we want to implement a TE system based on \nValiant Load\nBalancing (VLB)\n with YATES, and compare it with\nother TE approaches.  Essentially, VLB routes traffic by forwarding flows from\na source to a destination through random intermediate nodes. It takes the\nshortest paths to route from source to intermediate nodes, and from\nintermediate nodes to the destination.\n\n\nBackground\n\n\nMost functionality for implementing TE algorithms in YATES resides in\n\nlib/routing\n.\nA TE algorithm module has the following interface:\n\n\nmodule\n \ntype\n \nAlgorithm\n \n=\n \nsig\n\n  \n(* Main function that computes the new routing scheme *)\n\n  \nval\n \nsolve\n \n:\n \ntopology\n \n-\n \ndemands\n \n-\n \nscheme\n\n\n  \n(* Optionally, initialize a TE module with a routing scheme *)\n\n  \nval\n \ninitialize\n \n:\n \nscheme\n \n-\n \nunit\n\n\n  \n(* Optionally, augment the TE algorithm with a way to handle failures *)\n\n  \nval\n \nlocal_recovery\n \n:\n \nscheme\n \n-\n \ntopology\n \n-\n \nfailure\n \n-\n \ndemands\n \n-\n \nscheme\n\n\nend\n\n\n\n\n\n\nThis interface uses types defined in \nlib/types/\n.\nThe most essential function in this interface is the  \nsolve\n function. \nsolve\n\ncomputes a routing scheme (of type \nscheme\n) given a topology (of type\n\ntopology\n) and traffic matrices (of type \ndemands\n). A routing \nscheme\n is a\nmapping from source-destination pairs to a probability distribution over paths\nbetween those pairs.\n\n\n(* Map from source-destination pair to it\ns required bandwidth *)\n\n\ntype\n \ndemands\n \n=\n \nfloat\n \nSrcDstMap\n.\nt\n\n\n\n(* Map from source-destination pair to a probability distribution over paths *)\n\n\ntype\n \nscheme\n \n=\n \n(\nfloat\n \nPathMap\n.\nt\n)\n \nSrcDstMap\n.\nt\n\n\n\n\n\n\nThe weight (or probability) of path \np\n in the distribution represents the\nrelative fraction of the source-destination traffic that should be sent over\n\np\n.\n\n\n\n\nImplementation\n\n\nWe start with writing a YATES TE module (\nVlb.ml\n) that implements the interface shown above.\n\n\nThe \nsolve\n\nfunction for VLB first pre-computes all-pair shortest paths for every pair of nodes using existing implementations provided in YATES.\n\n\n(* All shortest paths for all node pairs *)\n\n\nlet\n \nmpapsp\n \n=\n \nall_pairs_multi_shortest_path\n \ntopo\n \nin\n\n\n\n(* Get one shortest path per node pair *)\n\n\nlet\n \nspf_table\n \n=\n \nSrcDstMap\n.\nfold\n \nmpapsp\n \n~\ninit\n:\nSrcDstMap\n.\nempty\n\n  \n~\nf\n:(\nfun\n \n~\nkey\n:(\nv1\n,\nv2\n)\n \n~\ndata\n:_\n \nacc\n \n-\n\n      \nmatch\n \nget_random_path\n \nv1\n \nv2\n \ntopo\n \nmpapsp\n \nwith\n\n      \n|\n \nNone\n \n-\n \nacc\n\n      \n|\n \nSome\n \nrand_path\n \n-\n\n        \nSrcDstMap\n.\nset\n \nacc\n \n~\nkey\n:(\nv1\n,\nv2\n)\n \n~\ndata\n:\nrand_path\n)\n \nin\n\n\n\n(* Returns a shortest path from a given source to a given destination *)\n\n\nlet\n \nfind_path\n \nsrc\n \ndst\n \n=\n \nSrcDstMap\n.\nfind_exn\n \nspf_table\n \n(\nsrc\n,\ndst\n)\n \nin\n\n\n\n\n\n\nThen, we iterate over the pairs of source-destination nodes and for each\npair, we compute the set of paths through all possible detour nodes, and\ncreate a probability distribution over these paths, assigning uniform\nprobability for each path.\n\n\n(* A function that computes the shortest path through a given detour node.\n\n\n   It returns the concatenation of shortest src -\n det and det -\n dst nodes. *)\n\n\nlet\n \nroute_thru_detour\n \nsrc\n \ndet\n \ndst\n \n=\n\n  \nremove_cycles\n \n(\nfind_path\n \nsrc\n \ndet\n \n@\n \nfind_path\n \ndet\n \ndst\n)\n \nin\n\n\n\n(* Compute uniform probability distribution over paths through every possible\n\n\n   intermediate node for a given source and destination. *)\n\n\nlet\n \nvlb_pps\n \nsrc\n \ndst\n \n=\n\n  \n(* Find paths through all possible detours *)\n\n  \nlet\n \n(\npaths\n,\n \nnum_detours\n)\n \n=\n\n    \nTopology\n.\nfold_vertexes\n\n      \n(\nfun\n \nv\n \n(\np_acc\n,\n \nns_acc\n)\n \n-\n\n         \nmatch\n \ndevice\n \nv\n \nwith\n\n         \n|\n \nNode\n.\nSwitch\n \n-\n\n           \n(* Only route through switches *)\n\n           \n((\nroute_thru_detour\n \nsrc\n \nv\n \ndst\n)::\np_acc\n,\n \nns_acc\n \n+.\n \n1\n.)\n\n         \n|\n \n_\n \n-\n\n           \n(\np_acc\n,\n \nns_acc\n)\n \n)\n \ntopo\n \n(\n[]\n,\n \n0\n.)\n \nin\n\n  \n(* Generate uniform probability distribution *)\n\n  \nList\n.\nfold_left\n \npaths\n \n~\ninit\n:\nPathMap\n.\nempty\n \n~\nf\n:(\nfun\n \nacc\n \npath\n \n-\n\n      \nadd_or_increment_path\n \nacc\n \npath\n \n(\n1\n.\n0\n \n/.\n \nnum_detours\n))\n \nin\n\n\n\n\n\n\nFinally, we create a routing scheme that maps each\nsource-destination pair to its corresponding distribution over paths.\n\n\n(* Folding over mpapsp just to get all src-dst pairs *)\n\n\nSrcDstMap\n.\nfold\n \nmpapsp\n \n~\ninit\n:\nSrcDstMap\n.\nempty\n \n~\nf\n:(\nfun\n \n~\nkey\n:(\nv1\n,\nv2\n)\n \n~\ndata\n:_\n \nacc\n \n-\n\n    \nmatch\n \n(\ndevice\n \nv1\n,\n \ndevice\n \nv2\n)\n \nwith\n\n    \n|\n \n(\nNode\n.\nHost\n,\n \nNode\n.\nHost\n)\n \n-\n\n      \nSrcDstMap\n.\nset\n \nacc\n \n~\nkey\n:(\nv1\n,\nv2\n)\n \n~\ndata\n:(\nvlb_pps\n \nv1\n \nv2\n)\n\n    \n|\n \n_\n \n-\n \nacc\n)\n\n\n\n\n\n\nSee \nlib/routing/Vlb.ml\n\nfor the complete implementation.\n\n\nTo make the YATES simulator aware of the new TE algorithm, we need to perform a\nfew more steps. We create an interface \nVlb.mli\n for the new VLB module.\nThis interface is basically the same as we showed earlier.\nWe create an identifier \nVlb\n for this module by adding it to \nYates_Routing.ml\n and \nYates_Routing.mli\n. The VLB routing module is now ready. For use within the simulator, we would also need to add VLB as a solver type (see \nhere\n) and define any \nhelper functions\n and a \nCLI flag\n.\nThis new TE system can be used by simply specifying it's flag in the YATES CLI.\nFor example, to compare ECMP and VLB on the example Abilene topology, we can\nrun:\n\n\n$ make \n make install\n$ yates data/topologies/abilene.dot \n\\\n\n  data/demands/actual/abilene.txt data/demands/predicted/abilene.txt \n\\\n\n  data/hosts/abilene.hosts -ecmp -vlb", 
            "title": "Extending YATES"
        }, 
        {
            "location": "/extending/#extending-yates", 
            "text": "One of the primary objectives of YATES is to enable rapid prototyping of TE\nsystems. This page will demonstrate how to implement a new TE algorithm with\nYATES.", 
            "title": "Extending YATES"
        }, 
        {
            "location": "/extending/#example-valiant-load-balancing-vlb", 
            "text": "VLB : Suppose we want to implement a TE system based on  Valiant Load\nBalancing (VLB)  with YATES, and compare it with\nother TE approaches.  Essentially, VLB routes traffic by forwarding flows from\na source to a destination through random intermediate nodes. It takes the\nshortest paths to route from source to intermediate nodes, and from\nintermediate nodes to the destination.", 
            "title": "Example: Valiant Load Balancing (VLB)"
        }, 
        {
            "location": "/extending/#background", 
            "text": "Most functionality for implementing TE algorithms in YATES resides in lib/routing .\nA TE algorithm module has the following interface:  module   type   Algorithm   =   sig \n   (* Main function that computes the new routing scheme *) \n   val   solve   :   topology   -   demands   -   scheme \n\n   (* Optionally, initialize a TE module with a routing scheme *) \n   val   initialize   :   scheme   -   unit \n\n   (* Optionally, augment the TE algorithm with a way to handle failures *) \n   val   local_recovery   :   scheme   -   topology   -   failure   -   demands   -   scheme  end   This interface uses types defined in  lib/types/ .\nThe most essential function in this interface is the   solve  function.  solve \ncomputes a routing scheme (of type  scheme ) given a topology (of type topology ) and traffic matrices (of type  demands ). A routing  scheme  is a\nmapping from source-destination pairs to a probability distribution over paths\nbetween those pairs.  (* Map from source-destination pair to it s required bandwidth *)  type   demands   =   float   SrcDstMap . t  (* Map from source-destination pair to a probability distribution over paths *)  type   scheme   =   ( float   PathMap . t )   SrcDstMap . t   The weight (or probability) of path  p  in the distribution represents the\nrelative fraction of the source-destination traffic that should be sent over p .", 
            "title": "Background"
        }, 
        {
            "location": "/extending/#implementation", 
            "text": "We start with writing a YATES TE module ( Vlb.ml ) that implements the interface shown above.  The  solve \nfunction for VLB first pre-computes all-pair shortest paths for every pair of nodes using existing implementations provided in YATES.  (* All shortest paths for all node pairs *)  let   mpapsp   =   all_pairs_multi_shortest_path   topo   in  (* Get one shortest path per node pair *)  let   spf_table   =   SrcDstMap . fold   mpapsp   ~ init : SrcDstMap . empty \n   ~ f :( fun   ~ key :( v1 , v2 )   ~ data :_   acc   - \n       match   get_random_path   v1   v2   topo   mpapsp   with \n       |   None   -   acc \n       |   Some   rand_path   - \n         SrcDstMap . set   acc   ~ key :( v1 , v2 )   ~ data : rand_path )   in  (* Returns a shortest path from a given source to a given destination *)  let   find_path   src   dst   =   SrcDstMap . find_exn   spf_table   ( src , dst )   in   Then, we iterate over the pairs of source-destination nodes and for each\npair, we compute the set of paths through all possible detour nodes, and\ncreate a probability distribution over these paths, assigning uniform\nprobability for each path.  (* A function that computes the shortest path through a given detour node.     It returns the concatenation of shortest src -  det and det -  dst nodes. *)  let   route_thru_detour   src   det   dst   = \n   remove_cycles   ( find_path   src   det   @   find_path   det   dst )   in  (* Compute uniform probability distribution over paths through every possible     intermediate node for a given source and destination. *)  let   vlb_pps   src   dst   = \n   (* Find paths through all possible detours *) \n   let   ( paths ,   num_detours )   = \n     Topology . fold_vertexes \n       ( fun   v   ( p_acc ,   ns_acc )   - \n          match   device   v   with \n          |   Node . Switch   - \n            (* Only route through switches *) \n            (( route_thru_detour   src   v   dst ):: p_acc ,   ns_acc   +.   1 .) \n          |   _   - \n            ( p_acc ,   ns_acc )   )   topo   ( [] ,   0 .)   in \n   (* Generate uniform probability distribution *) \n   List . fold_left   paths   ~ init : PathMap . empty   ~ f :( fun   acc   path   - \n       add_or_increment_path   acc   path   ( 1 . 0   /.   num_detours ))   in   Finally, we create a routing scheme that maps each\nsource-destination pair to its corresponding distribution over paths.  (* Folding over mpapsp just to get all src-dst pairs *)  SrcDstMap . fold   mpapsp   ~ init : SrcDstMap . empty   ~ f :( fun   ~ key :( v1 , v2 )   ~ data :_   acc   - \n     match   ( device   v1 ,   device   v2 )   with \n     |   ( Node . Host ,   Node . Host )   - \n       SrcDstMap . set   acc   ~ key :( v1 , v2 )   ~ data :( vlb_pps   v1   v2 ) \n     |   _   -   acc )   See  lib/routing/Vlb.ml \nfor the complete implementation.  To make the YATES simulator aware of the new TE algorithm, we need to perform a\nfew more steps. We create an interface  Vlb.mli  for the new VLB module.\nThis interface is basically the same as we showed earlier.\nWe create an identifier  Vlb  for this module by adding it to  Yates_Routing.ml  and  Yates_Routing.mli . The VLB routing module is now ready. For use within the simulator, we would also need to add VLB as a solver type (see  here ) and define any  helper functions  and a  CLI flag .\nThis new TE system can be used by simply specifying it's flag in the YATES CLI.\nFor example, to compare ECMP and VLB on the example Abilene topology, we can\nrun:  $ make   make install\n$ yates data/topologies/abilene.dot  \\ \n  data/demands/actual/abilene.txt data/demands/predicted/abilene.txt  \\ \n  data/hosts/abilene.hosts -ecmp -vlb", 
            "title": "Implementation"
        }
    ]
}